# 

# Algorithm

---

1. 배열(Array)
   
   - 2차원 배열
     
     - 1차원 list를 묶어 놓은 list
     
     - 2차원 이상의 다차원 list는 차원에 따라 index 선언
     
     - 2차원 list의 선언 
       
       - 세로길이(행의 개수)
       
       - 가로길이(열의 개수)
     
     - python에서는 데이터 초기화를 통해 변수선언과 초기화 가능
     
     - ex)`[[0,1,2,3],[4,5,6,7]]`(2행 4열 2차원 리스트)
       
       | 0   | 1   | 2   | 3   |
       | --- | --- | --- | --- |
       | 4   | 5   | 6   | 7   |
     
     - input 방법 
       
       - ```python
         N = int(input())
         arr = [list(map(int,input().split())) for i in range(N)]
         # 띄어쓰기 없이 입력시 .split() 삭제
         ```
       
       ---
   
   - 2차열 배열의 접근
     
     - 배열 순회
       
       - n * m 배열의 n * m 개의 모든 원소를 빠짐없이 조사하는 방법
       
       - 행 우선 순회
         
         - ```python
           for i in range(N(행의 개수)):
               for j in range(M(열의 개수)):
                   arr[i][j]
           # 행의 개수 = len(arr) / 열의 개수 = len(arr[0])
           ```
       
       - 열 우선 순회
         
         - ```python
           for j in range(M(열의 개수)):
               for i in range(N(행의 개수)):
                   arr[i][j]
           # 행의 개수 = len(arr) / 열의 개수 = len(arr[0])
           ```
       
       - 지그재그 순회
         
         - ```python
           for i in range(N(행의 개수)):
               for j in range(M(열의 개수)):
                   arr[i][j + (m-1-2*j) * (i%2)]
           # 행의 개수 = len(arr) / 열의 개수 = len(arr[0])
           ```
   
   ---
   
   - 델타를 이용한 2차 배열 탐색
     
     - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
     
     - ```python
       arr[0...N-1][0...N-1] # N * N 배열
       di = [-1, 0, 1, 0] #상우하좌 순서
       dj = [0, 1, 0, -1] #상우하좌 순서
       for i in range(N):
           for j in range(N):
               for k in range(4):
                   ni = i +di[k]
                   nj = j +dj[k]
                   if 0 <= ni < N and 0 <= nj < N: #유효한 인덱스 면
                       test(arr[ni][nj])
       ```
     
     - ```python
       for i in range(N):
           for j in range(N):
               for di, dj in [[-1, 0,], [0, 1], [1, 0], [0, -1]]:
                   ni, nj = i + di, j + dj
                   if 0 <= ni < N and 0 <= nj < N: 
       ```
   
   ---
   
   - 2차원 배열의 활용
     
     - 전치행렬 : 행과 열을 바꾼 값
   
   ---
   
   - 부분집합 합(subset sum) 문제
     
     - 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
     
     - ex) [-7, -3, -2, 5, 8]라는 집합이 있을때 [-3, 2, 5]는 이 집합의 부분집합이면서 합이 0이 되므로 참이된다.
     
     - 부분집합의 수
       
       - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개
       
       - 각 원소를 부분집하에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다
       
       - ex) {1,2,3,4} / 2\*2\*2\*2 = 16가지
     
     - 각 원소가 부분집합에 포함되었는지를 loop 이용하여 확인하고 부분집합을 생성하는 방법
       
       - ```python
         bit = [0, 0, 0, 0]
         for i in range(2):
             bit[0] = i                    # 0번째 원소
             for j in range(2):
                 bit[1] = j                # 1번째 원소
                 for k in range(2):
                     bit[2] = k            # 2번째 원소
                     for l in range(2):
                         bit[3] = l        # 3번째 원소
                         print_subset(bit) # 생성된 부분집합 출력
         ```
     
     ---
   
   - 비트연산자
     
     - 같은 자리에서만 연산을 한다.
       
       - & : 비트 단위로 AND 연산을 한다.
         
         - i & (1 << j) 
         
         - i의 j번째 비트가 1인지 아닌지를 검사
       
       - | : 비트 단위로 OR 연산을 한다.
       
       - << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
         
         - 1 << n  : 2^n
         
         - 즉, 원소가 n개일 경우의 모든 부분집합의 수
       
       - \>> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
       
       - ```python
         arr = [3, 6, 7, 1, 5, 4]
         n = len(arr)                  # n : 원소의 개수
         for i in range(1 << n):       # 1 << n : 부분집합의 개수 
             for j in range(n):        # 원소의 수만큼 비트를 비교
                 if i & (1<<j):        # i의 j번 비트가 1인경우
                     print(arr[j], end=",")   # j번 원소 출력
             print()
         print()
         ```
     
     ---
   
   - 검색(search)
     
     - 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
     
     - 목적하는 탐색키를 가진 항목을 찾는 것
       
       - 탐색키(search key) : 자료를 구별하여 인식할 수 있는 키
     
     - 검색의 종류 
       
       1. 순차 검색(sequential search)
       
       2. 이진 검색(binary search)
       
       3. 해쉬(hash)
       
       ---
     1. 순차 검색(일렬로 되어 있는 자료를 순서대로 검색하는 방법)
        
        - 가장 간단하고 직관적인 검색방법
        
        - 배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용
        
        - 알고리즘이 단순하여 구현이 쉽지만, 검색대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율
        
        - 2가지 경우
          
          - 정렬되어 있지 않은 경우
          
          - 검색과정
            
            - 첫번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다
            
            - 키 값이 동일한 원소를 찾으면 그원소의 인덱스 반환
            
            - 자료 구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
            
            - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
              
              - 정렬되지 않은 자료에서 순차 검색의 평균 비교회수
                
                - (1/n) * (1+2+3+...+n) = (n+1) / 2
            
            - ```python
              def seqentialsearch(a, n, key)
                  i <- 0
                  while i < n and a[i]! = key:
                      i <- i+1
                  if i < n : return i
                  else: return -1
              ```
          
          - 정렬되어 있는 경우
            
            - 자료를 순차적으로 검색하면서 키값을 비교하여, 원소의 키 값이 검색대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료한다.
            
            - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
              
              - 정렬이 되어있어 검색 실패 시 평균 비교회수가 반으로 줄어든다
              
              - 시간복잡도 : O(n)
            
            - ```python
              def seqentialsearch(a, n, key)
                     i <- 0
                     while i < n and a[i] < key:
                         i <- i+1
                     if i < n and a[i] == key:
                         return i
                     else:
                         return -1
              ```
     
     ---
     
     2. 이진검색(binary seatch)
        
        - 자료의 가운데 있는 항목의 키값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행
          
          - 목적 키를 찾을 때 까지 이진 검색을 반복 순행하여, 검색범위를 반으로 줄여가면서 보다 빠르게 검색
        
        - 이진 검색을 하기 위해 자료가 정렬된 상태여야 한다
        
        - 검색과정
          
          - 자료의 중앙에 있는 원소를 고른다
          
          - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다
          
          - 목표값이 중앙원소보다 작으면 자료의 왼쪽 반에서, 크다면 자료의 오른쪽 반에 대해 검색 수행
          
          - 찾을때 까지 위 과정 반복
        
        - 구현
          
          - 검색 범위의 시작점과 종료점을 이용하여 검색 반복
          
          - 자료 삽입이나 삭제가 발생 했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요
        
        - ```python
          def binarysearch(a, N, key)
              start = 0
              end = N - 1
              while start <= end:
                  middle = (start + end)//2
                  if a[middle] == key:          # 검색 성공 
                      return true
                  elif a[middle] > key:
                      end = middle -1
                  else:
                      start = middle + 1
              return false                      # 검색 실패
          ```
        
        - 재귀 함수 이용 가능

---

2. 정렬
   
   - 인덱스
     
     - database에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. database 분야가 아닌 곳에서는 look up table 등의 용어를 사용한다
     
     - 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하고 있는데 필요한 디스크 공간보다 작다.
       
       - 보통 인데스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.
     
     - 배열을 사용한 인덱스
       
       - 대량의 데이터를 매번 정렬하면, 반응이 느려지기 때문에 대량의 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스 사용
   
   ---
   
   - 정렬방식의 종류
     
     - 선택 정렬(selction sort)
       
       - 알고리즘 기법 
         
         - 비교와 교환
         
         - 교환 회수가 버블 / 삽입정렬보다 작다
       
       - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
       
       - 정렬과정
         
         - 주어진 리스트 중에서 최소값을 찾는다
         
         - 그 값을 리스트의 맨앞에 위치한 값과 교환
         
         - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 과정 반복
       
       - 시간복잡도 : O(n2)
       
       - ```python
         def selectionsort(a, N):
             for i in range(N-1):
                 minidx = i
                 for j in range(i+1, N):
                     if a[minidx] > a[j]:
                         minidx = j
                 a[i], a[minidx] = a[minidx], a[i]
         ```
       
       - 셀렉션 알고리즘
         
         - 저장되어 있는 자료로부터 K번째로 큰 혹은 작은 원소를 찾는 방법을 셀력션 알고리즘이라 한다.
           
           - 최대 최소 혹은 중간값을 찾는 알고리즘을 의미
         
         - 선택과정
           
           - 정렬 알고리즘을 이용하여 자료정렬
           
           - 원하는 순서에 있는 원소 가져오기
