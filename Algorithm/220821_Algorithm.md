# Algorithm

---

## 배열 1

---

- 알고리즘 
  
  - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
  
  - 컴퓨터가 **어떤 일을 수행하기 위한 단계적 방법**
  
  - 표현방법
    
    - 의사코드(pseudo code)
    
    - 순서도
  
  - 좋은 알고리즘
    
    1. 정확성 : 얼마나 정확하게 동작하나
    
    2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내나
    
    3. 메모리 사용량 : 얼마나 적은 메모리를 사용하나
    
    4. 단순성 : 얼마나 단순한가
    
    5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가
  
  - 성능분석
    
    - 시간복잡도(Time complexity) 
      
      - 실제 걸리는 시간 측정
      
      - 실행되는 명령문의 개수를 계산
    
    - 빅오표기법(big oh notation)
      
      - 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만 표시
      
      - 계수(Coefiicient)는 생략하여 표시

---

- 배열
  
  - 일정한 자료형의 **변수들을 하나의 이름으로 열거하여 사용**하는 자료구조
  
  - 필요성
    
    - 여러개의 변수가 필요할 때 일일이 다른 변수명을 이용하여 자료에 접근하는 비효율성을 막을 수 있다
    
    - 하나의 선언을 통해 둘 이상의 변수선언이 가능
    
    - 다수의 변수로 하기 힘든 작업을 배열을 활용하여 쉽게 할 수 있다
  
  - 1차원 배열의 선언
    
    - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
    
    - 이름 : 프로그램에서 사용할 배열의 이름
  
  - 1차원 배열의 접근
    
    - arr[0] = 10 / arr의 0번째 원소에 10을 저장

---

- 정렬
  
  - 오름차순 혹은 내림차순으로 재배열 하는 것
  
  - 키
    
    - 자료를 정렬하는 기준이 되는 특정 값
  
  - 정렬방식의 종류
    
    1. 버블정렬
       
       - 인접한 두개의 원소를 비교하면 자료를 교환하는 방식
       
       - 시간복잡도 O(n^2)
    
    2. 카운팅정렬
       
       - 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여 정렬
       
       - 시간복잡도 O(n+k)
       
       - 제한사항
         
         - 정수나 정수로 표현할 수 있는 자료형만 가능
         
         - 가장 큰 정수를 알아야 카운트를 위한 공간할당이 가능
    
    3. 선택정렬
    
    4. 퀵정렬
    
    5. 삽입정렬
    
    6. 병합정렬

---

- 완전검색(exaustive search)
  
  - 문제의 해법을 모두 나열하여 테스트한 후 최종 해법 도출
    
    - 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만 해답을 찾을 확률이 높다
  
  - 경우의 수가 작을 때 유용
  
  - **brute-force** (generate and test)라고 부름

---

- 순열(permutation)
  
  - 서로 다른 것들 중 몇 개를 뽑아서 한줄로 나열
  
  - 순열을 생성하는 함수

--- 

- 탐욕(greedy) 알고리즘
  
  - 최적해를 찾는 근시안적방법
  
  - 여러 경우 중 하나를 결정해야 할 때 최적이라고 생각되는 것을 선택에 답을 찾아냄
  
  - 완성 시 최적해라는 보장은 없음
  
  - 동작과정
    
    - 해선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤 부분해집합에 추가
    
    - 실행가능성검사 : 새로운 부분해 집합이 실행 가능한지 확인
    
    - 해검사 : 부분해집합이 문제의 해가 되는지 확인 아니라면 해선택부터 다시시작

---

## 배열2

---

- 2차원 배열
  
  - 선언
    
    - 1차원리스트를 묶어놓은 리스트
    
    - 차원에 따라 인덱스를 선언 / list[행][열]
  
  - 배열 순회
    
    - NXM의 배열에서 n*m개의 모든 원소를 조사하는 방법
    
    - 종류
      
      - 행우선순회
      
      - 열우선순회
      
      - 지그재그순회
    
    - 델타를 이용한 배열탐색
    
    - 전치행렬
  
  - 부분집합의 수
    
    - 집합의 원소가 n개일 때 공집합을 포함한 부분집합의 수는 2^n개이다
    
    - 비트연산
      
      - &
        
        - 비트 단위로 and연산
      
      - |
        
        - 비트 단위로 or 연산
      
      - <<
        
        - 피연산자의 비트열을 왼쪽으로 이동
      
      - \>>
        
        - 피연산자의 비트열을 오른쪽으로 이동

---

- 검색
  
  - 저장된 항목 중 원하는 것을 찾는 작업
  
  - 목적하는 탐색 키를 가진 항목을 찾는 것
  
  - 검색의 종류
    
    - 순차 검색
      
      - 일렬로 되어 있는 자료를 순서대로 검색하는 방법
        
        - 가장 간단하고 직관적인 검색방법
        
        - 배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목 찾을 때 유용
        
        - 알고리즘이 단순하여 구현이 쉽지만 검색 대상의 수가 많은 경우 시간이 오래걸려 비효율적
    
    - 이진 검색
      
      - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
      
      - 정렬된 상태여야만 사용 가능
    
    - 해쉬

---

- 인덱스
  
  - 테이블에 대한 동작 속도를 높여주는 자료구조
  
  - 테이블보다 저장할 때 필요한 공간이 작아 속도가 빠르다

---

- 선택정렬
  
  - 주어진 자료 중 가장 작은 값의 원소 부터 차례대로 선택하여 위치를 교환하는 방식
  
  - 시간복잡도 O(n^2)

---

## 문자열

---

- 문자의 표현
  
  - 컴퓨터에서의 문자표현
    
    - ASCII(american standard code for information interchange) 문자인코딩표준
      
      - 7bit로 128문자표현 가능 : 33개는 출력 불가 /95개는 공백을 비롯한 출력 가능
    
    - 다국어 처리를 위한 표준 : 유니코드
  
  - 문자열 처리
    
    - +이어붙이기
    
    - *문자열 반복

- 패턴매칭
  
  - brute force 고지식한 알고리즘
    
    - 문자열을 일일이 비교하는 방식
  
  - kmp 알고리즘
    
    - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지 알기에 불일치가 발생한 앞 부분에 대해 비교하지 않고 건너 뜀
  
  - 보이어무어 알고리즘
    
    - 대부분 사용 알고리즘에서 채택한 방법
    
    - 패턴내 일치하는 것이 없으면 패턴만큼 건너 뜀
    
    - 끝자리가 일치하지 않을때 끝자리를 패턴 내 일치하는 것과 맞춤

---

## stack1

---

- 스택 
  
  - 물건을 쌓아 올리듯 자료를 쌓은 자료구조
  
  - 선형구조를 갖는다
  
  - 후입선출
  
  - 연산
    
    - 삽입 push
    
    - 삭제 pop
    
    - 공백확인 isEmpty
    
    - 원소 반환 peek

---

- 재귀호출
  
  - 자기 자신을 호출하여 순환 수행

- Memoization
  
  - 중복호출 방지
  
  - 한번 계산한 것을 저장하여 다음에 사용

---

- DP
  
  - 동적계획 : 최적화 문제 해결
    
    - 문제를 분할하고
    
    - 가장 작은 문제부터 해를 구한후
    
    - 테이블에 저장하여 부분 문제를 해를 사용해 상위문제를 해결한다
  
  - 구현방식
    
    - recursive
    
    - iterative

---

- DFS(깊이 우선 탐색)
  
  - 비선형 구조인 그래프 구조는 모두 검색하는 것이 중요
  
  - 시작점에서 끝점까지 방문할 수 있는 모든 경우를 센다
  
  - 알고리즘
    
    - 시작 정점을 결정하여 방문하고
    
    - 인접한 정점 중 방문하지 않은 곳을 방문하여 방문표시 후 다음으로 넘어가는 것을 반복하여 스택이 공백이 될때까지 이동
